[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "",
    "text": "Functions for generating, visualizing, and comparing maps (Faye et al. 2024). The example below illustrates a comparison between two maps at different spatial resolutions, with each map composed of labeled grid cells.\nTo facilitate meaningful comparison, the map with the finer resolution is disaggregated to match the coarser resolution. Corresponding grid cells are then compared based on their assigned class labels. An agreement score is computed to assess the level of correspondence between the two maps. Grid cells where labels match are marked as “Match = Yes”, providing a straightforward visual and quantitative measure of classification agreement."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html#required-r-packages",
    "href": "index.html#required-r-packages",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "1.1 Required R Packages",
    "text": "1.1 Required R Packages\n\n\nCode\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(sp)\nlibrary(sf)\nlibrary(ggspatial)\nlibrary(ggpubr)\nlibrary(ggnewscale)\nlibrary(raster)"
  },
  {
    "objectID": "index.html#required-functions",
    "href": "index.html#required-functions",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "1.2 Required functions",
    "text": "1.2 Required functions\n\n\nCode\nsource('status-prop.R')\nsource('disaggregate.R')\nsource('match.R')\nsource('balanced-match.R')"
  },
  {
    "objectID": "index.html#creation",
    "href": "index.html#creation",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "2.1 Creation",
    "text": "2.1 Creation\nA study area map is created using specified coordinates to form a polygon with the WGS84 reference system.\n\n\nCode\ncrdref &lt;- CRS('+proj=longlat +datum=WGS84')\ncrdref2 &lt;- st_crs('+proj=longlat +datum=WGS84')\n\nlon &lt;- c(-116.8, -114.2, -112.9, -111.9, -114.2, -115.4, -117.7)\nlat &lt;- c(41.3, 42.9, 42.4, 39.8, 37.9, 38.3, 38.6)\nlonlat &lt;- cbind(lon, lat)\npolygon &lt;- Polygon(lonlat)\npols=Polygons(list(polygon), ID = \"1\")\npols = SpatialPolygons(list(pols), proj4string = CRS(\"+proj=longlat +datum=WGS84\"))\npols_sf=st_as_sf(pols)\nst_crs(pols_sf) = crdref\n\ntheme_cust = theme(panel.grid.major = element_blank(), \n         panel.grid.minor = element_blank(),\n          panel.background = element_blank(),\n         plot.background = element_rect(colour = \"black\", fill=NA, linewidth=1),\n          legend.key=element_blank(), \n          legend.text=element_text(size=15,face=\"bold\"),\n         legend.title=element_text(size=15,face=\"bold\"),\n         axis.title=element_text(size=15,face=\"bold\"),\n          axis.line = element_line(colour = \"black\"),\n          axis.text = element_text(face=\"bold\"), \n          axis.text.x = element_text(face=\"bold\", size=11),\n          axis.text.y = element_text(face=\"bold\", size=11),\n          plot.title=element_text(size=10))\n\n\nsamap = ggplot(pols_sf) +\n  labs(x=\"Longitude\", y=\"Latitude\", tag=\"A\")+\n   geom_sf(color = \"blue\", fill=\"yellow\")+\n  annotation_scale(location = \"bl\") +\n  annotation_north_arrow(location = \"tr\", which_north= \"true\", height = unit(.5, \"cm\"),\n  width = unit(.5, \"cm\"), pad_x = unit(.5, \"cm\"))+ theme_cust\n  \nsamap"
  },
  {
    "objectID": "index.html#rasterization",
    "href": "index.html#rasterization",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "2.2 Rasterization",
    "text": "2.2 Rasterization\nA gridded raster is generated within the study area, with red points overlaying the raster cells, and the polygon, raster, and points are visualized on a map.\n\n\nCode\nref_sp = raster(xmn = extent(pols)[1], xmx = extent(pols)[2], ymn = extent(pols)[3], ymx = extent(pols)[4], res = c(.5,.5))\n\ncrs(ref_sp) = crdref\n\npts = SpatialPoints(rasterToPoints(ref_sp))\n\npts_df=as.data.frame(pts)\nnames(pts_df) = c(\"Longitude\", \"Latitude\")\n\nvalues(ref_sp)= rep(0, ncell(ref_sp))\n\ncrs(pts) = crdref\n\n\nref_sp_df = cbind(xyFromCell(ref_sp, 1:ncell(ref_sp)), values(ref_sp))\nref_sp_df =  as.data.frame(ref_sp_df)\nnames(ref_sp_df) = c(\"Longitude\", \"Latitude\", \"Class\")\nref_sp_df$Class = as.factor(ref_sp_df$Class)\n\n\nrasmap = ggplot(pols_sf) +\n  geom_sf(color = \"blue\", fill=\"yellow\")+\n  geom_tile(data=ref_sp_df, aes(x=Longitude, y=Latitude, fill=Class), color=\"black\", alpha=0)+\n  scale_fill_manual(\"\", values = \"white\", guide=\"none\", limits=force)+\n  geom_point(data = pts_df, aes(x=Longitude, y=Latitude), color=\"red\")+\n  labs(tag=\"A'\")+\n  annotation_scale(location = \"br\", text_cex = 0.5, pad_y = unit(0.15, \"cm\")) +\n  annotation_north_arrow(location = \"tr\", which_north= \"true\", height = unit(.5, \"cm\"),\n  width = unit(.5, \"cm\"), pad_x = unit(.5, \"cm\"))+ theme_cust\nrasmap"
  },
  {
    "objectID": "index.html#reference-map",
    "href": "index.html#reference-map",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "3.1 Reference map",
    "text": "3.1 Reference map\nA reference map is created by assigning labels to each raster grid cell.\n\n\nCode\nr = raster(xmn = extent(pols)[1], xmx = extent(pols)[2], ymn = extent(pols)[3], ymx = extent(pols)[4], res = c(1,1))\nset.seed(12)\nvalues(r)= sample(1:5, ncell(r), replace=T)\nr2 = raster::disaggregate(r, fact=2)\n\n# Put data in the raster\nset.seed(1)\nvalues(ref_sp)= values(r2)\n\n# Mask raster\nref_sp_mask = mask(ref_sp, pols, updateNA=T)\n\nref_sp_mask_df = cbind(xyFromCell(ref_sp_mask, 1:ncell(ref_sp_mask)), values(ref_sp_mask))\nref_sp_mask_df =  as.data.frame(ref_sp_mask_df)\nnames(ref_sp_mask_df) = c(\"Longitude\", \"Latitude\", \"Class\")\n\nref_sp_mask_df$Class = as.factor(ref_sp_mask_df$Class)\n\n\npols_sf = st_as_sf(pols)\nst_crs(pols_sf) = crdref\n\ncolab = c(\"1\" = \"#dee273\",\n          \"2\" = \"#dcbf64\",\n          \"3\" = \"#a5bfdd\",\n          \"4\" = \"#1f77b6\",\n          \"5\" = \"#02426d\")\n\nrmap = ggplot(pols_sf) +\n  geom_tile(data=ref_sp_mask_df, aes(x=Longitude, y=Latitude, fill=Class), linewidth=0.1, color=\"black\")+\n  labs(title =\"Reference map\", tag=\"B\")+\n  scale_fill_manual(\"Class\", values = colab, na.value = \"white\", limits=force) +\n  geom_sf(color = \"blue\", fill=NA) +\n  annotation_scale(location = \"br\", text_cex = 0.5, pad_y = unit(0.05, \"cm\"),\n  height = unit(0.1, \"cm\")) +\n  annotation_north_arrow(location = \"tr\", which_north= \"true\", height = unit(.5, \"cm\"),\n  width = unit(.5, \"cm\"), pad_x = unit(.1, \"cm\"))+theme_cust\n\n\npng(\"refmap.png\")\nprint(rmap)\ninvisible(invisible(dev.off()))\n\nrmap"
  },
  {
    "objectID": "index.html#prediction-map",
    "href": "index.html#prediction-map",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "3.2 Prediction map",
    "text": "3.2 Prediction map\nA prediction map is created by assigning labels to each raster grid cell for comparison.\n\n\nCode\npred_sp = r\npred_sp[[1]][c(9,17,21)] = c(5,1,4)\n\npred_sp_mask = mask(pred_sp, pols, updateNA=T)\n\npred_sp_mask_df = cbind(xyFromCell(pred_sp_mask, 1:ncell(pred_sp_mask)), values(pred_sp_mask))\npred_sp_mask_df =  as.data.frame(pred_sp_mask_df)\nnames(pred_sp_mask_df) = c(\"Longitude\", \"Latitude\", \"Class\")\n\n\npred_sp_mask_df$Class = as.factor(pred_sp_mask_df$Class)\n\npmap = ggplot(pols_sf) +\n  geom_tile(data=pred_sp_mask_df, aes(x=Longitude, y=Latitude, fill=Class), linewidth=0.1, color=\"black\")+\n  scale_fill_manual(\"Class\", values = colab, na.value = \"white\", limits=force) +\n  labs(title =\"Prediction map\", tag=\"C\") +\n  geom_sf(color = \"blue\", fill=NA) +\n  annotation_scale(location = \"br\", text_cex = 0.5, pad_y = unit(0.05, \"cm\"),\n  height = unit(0.1, \"cm\")) +\n annotation_north_arrow(location = \"tr\", which_north= \"true\", height = unit(.5, \"cm\"),\n  width = unit(.5, \"cm\"), pad_x = unit(.1, \"cm\"))+theme_cust\n\n\npng(\"predmap.png\")\nprint(pmap)\ninvisible(dev.off())\n\npmap"
  },
  {
    "objectID": "index.html#cell-size-adjustment",
    "href": "index.html#cell-size-adjustment",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "4.1 Cell Size Adjustment",
    "text": "4.1 Cell Size Adjustment\nThe prediction map cells are adjusted to match the cell size of the reference map.\n\n\nCode\npred_sp_dis = disagRast(pols, pred_sp_mask, ref_sp, crdref)\n\n\npred_sp_dis_df = cbind(xyFromCell(pred_sp_dis, 1:ncell(pred_sp_dis)), values(pred_sp_dis))\npred_sp_dis_df =  as.data.frame(pred_sp_dis_df)\nnames(pred_sp_dis_df) = c(\"Longitude\", \"Latitude\", \"Class\")\n\n\npred_sp_dis_df$Class = as.factor(pred_sp_dis_df$Class)\n\npmapdis = ggplot(pols_sf) +\n  geom_tile(data=pred_sp_dis_df, aes(x=Longitude, y=Latitude, fill=Class), linewidth=0.1, color=\"black\")+\n  scale_fill_manual(\"Class\", values = colab, na.value = \"white\", limits=force) +\n  labs(title =\"Prediction map disaggregated\", tag=\"D\") +\n  geom_sf(color = \"blue\", fill=NA) +\n  annotation_scale(location = \"br\", text_cex = 0.5, pad_y = unit(0.05, \"cm\"),\n  height = unit(0.1, \"cm\")) +\n annotation_north_arrow(location = \"tr\", which_north= \"true\", height = unit(.5, \"cm\"),\n  width = unit(.5, \"cm\"), pad_x = unit(.1, \"cm\"))+theme_cust\n\n\npng(\"predismap.png\")\nprint(pmapdis)\ninvisible(dev.off())\n\npmapdis"
  },
  {
    "objectID": "index.html#cell-marking",
    "href": "index.html#cell-marking",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "4.2 Cell marking",
    "text": "4.2 Cell marking\nThe prediction map cells are labeled according to their location in the grid.\n\n\nCode\nref_spbis=ref_sp\nref_spbis[is.na(ref_spbis)] = 999\n# Cells outside the study area\n\noutstudy = mask(ref_spbis, pols, updateNA=T)\n\nstatus = statusProp(pred_sp_dis, ref_sp, outstudy[[1]], pols, 4326)\n\nout_df = status[[1]]\ninP_df = status[[2]]\ninNP_df = status[[3]]\nPropNL = status[[4]]\nPropL = status[[5]]\n\nallcells = rbind(out_df, inP_df, inNP_df)\nnames(allcells) = c(\"Longitude\", \"Latitude\", \"Class\", \"Location\")\n\ncolab3 = c(\"Outside\"=\"white\", \"Inside-P\"=\"green\", \"Inside-Non-P\"=\"orange\")\nlab3 = c(\"Outside\"= \"O\", \"Inside-P\"=\"L\", \"Inside-Non-P\"=\"NL\")\nstatusmap =  ggplot(pols_sf) +\n  geom_tile(data=allcells, aes(x=Longitude, y=Latitude, fill=Location), linewidth=0.1, color=\"black\")+\n  scale_fill_manual(\"Status\", values = colab3, labels = lab3, limits=force) +\n  labs(title =\"Prediction map disaggregated marking\", tag=\"E\") +\n  geom_sf(color = \"blue\", fill=NA) +\n  annotation_scale(location = \"br\", text_cex = 0.5, pad_y = unit(0.05, \"cm\"),\n  height = unit(0.1, \"cm\")) +\n  annotation_north_arrow(location = \"tr\", which_north= \"true\", height = unit(.5, \"cm\"),\n  width = unit(.5, \"cm\"), pad_x = unit(.1, \"cm\"))+theme_cust\n\n\npng(\"statusmap.png\")\nprint(statusmap)\ninvisible(dev.off())\n\nstatusmap\n\n\n\n\n\n\n\n\n\n\nThe disaggregation of the prediction map will generate borders effects.\n\n\n\nCode\np1 =  ggpubr::ggarrange(rmap, pmap, pmapdis, statusmap,  ncol = 2, nrow = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nO = Cells outside the study area. We count 45 such cells.\nL + NL = Marked cells from the original prediction map, totaling 82 cells.\nL = Marked cells within the study area. We count 72 cells, which represents 0.88% of the total cells inside the study area.\nNL = Unmarked (non-labeled) cells within the study area. We count 10 cells, corresponding to 0.12%."
  },
  {
    "objectID": "index.html#compare-the-two-maps",
    "href": "index.html#compare-the-two-maps",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "4.3 Compare the two maps",
    "text": "4.3 Compare the two maps\nThe reference and the predicted maps are stacked to calculate the following “Match” and a “Balanced Match” scores.\n\n4.3.1 “Match” score\nThe match sccore corresponds to the proportion of cells that are identical in the both maps. It is calculated as follows:\n\\[\\begin{equation}\nMatch \\ (Yes) = \\frac{N_{+}}{N_{+} + N_{-}}\n\\end{equation}\\]\nwhere \\(N_{+}\\) are cells which labels are similar in the two maps and \\(N_{-}\\) are cells which labels are different in the two maps.\n\n\nCode\nmatchstats = matchRast(pred_sp_dis, ref_sp_mask, precision=2, correct=F)\n\nmatch = subset(matchstats[[1]][,], layer==1)[,3]\n\nmismatch = subset(matchstats[[1]][,], layer==0)[,3]\n\ncomp_sp = cbind(xyFromCell(matchstats[[2]], 1:ncell(matchstats[[2]])), values(matchstats[[2]]))\ncomp_sp_df =  as.data.frame(comp_sp)\nnames(comp_sp_df) = c(\"Longitude\", \"Latitude\", \"Class\")\n\n\ncomp_sp_df$Class = as.factor(comp_sp_df$Class)\n\ncolab2 = c(\"1\" = \"seagreen\", \"0\" = \"yellow\")\n\npmapcomp = ggplot(pols_sf) +\n  geom_tile(data=comp_sp_df, aes(x=Longitude, y=Latitude, fill=Class), linewidth=0.1, color=\"black\")+\n  scale_fill_manual(\"Match\", values = colab2, labels= c(\"1\"=str_glue(\"Yes = {match}\"), \"0\"= str_glue(\"No = {mismatch}\")), na.value = NA, limits=force) +\n  new_scale_fill()+\n  geom_tile(data=subset(allcells, Location==\"Inside-Non-P\"), aes(x=Longitude, y=Latitude), fill=\"orange\", linewidth=0.1, color=\"black\")+\n  labs(title =\"Non corrected Match\", tag=\"F\") +\n  geom_sf(color = \"blue\", fill=NA) +\n  annotation_scale(location = \"br\", text_cex = 0.5, pad_y = unit(0.05, \"cm\"),\n  height = unit(0.1, \"cm\")) +\n  annotation_north_arrow(location = \"tr\", which_north= \"true\", height = unit(.5, \"cm\"),\n  width = unit(.5, \"cm\"), pad_x = unit(.1, \"cm\"))+theme_cust\n\npng(\"pmapcomp.png\")\nprint(pmapcomp)\ninvisible(dev.off())\n\n\n########################################################################\n\nmatchstats = matchRast(pred_sp_dis, ref_sp_mask, precision=2, correct=T)\n\nmatch = subset(matchstats[[1]][,], layer==1)[,3]\n\nmismatch = subset(matchstats[[1]][,], layer==0)[,3]\n\n\ncomp_sp_corr = cbind(xyFromCell(matchstats[[2]], 1:ncell(matchstats[[2]])), values(matchstats[[2]]))\ncomp_sp_corr_df =  as.data.frame(comp_sp_corr)\nnames(comp_sp_corr_df) = c(\"Longitude\", \"Latitude\", \"Class\")\n\ncomp_sp_corr_df$Class = as.factor(comp_sp_corr_df$Class)\n\ncolab2 = c(\"1\" = \"seagreen\", \"0\" = \"yellow\")\n\npmapcompcorr = ggplot(pols_sf) +\n  geom_tile(data=comp_sp_corr_df, aes(x=Longitude, y=Latitude, fill=Class), linewidth=0.1, color=\"black\")+\n   scale_fill_manual(\"Match\", values = colab2, labels= c(\"1\"=str_glue(\"Yes = {match}\"), \"0\"= str_glue(\"No = {mismatch}\")), na.value = NA, limits=force) +\n  labs(title =\"Corrected Match \", tag=\"G\") +\n  geom_sf(color = \"blue\", fill=NA) +\n  annotation_scale(location = \"br\", text_cex = 0.5, pad_y = unit(0.05, \"cm\"),\n  height = unit(0.1, \"cm\")) +\n  annotation_north_arrow(location = \"tr\", which_north= \"true\", height = unit(.5, \"cm\"),\n  width = unit(.5, \"cm\"), pad_x = unit(.1, \"cm\"))+theme_cust\n\npng(\"pmapcompcorr.png\")\nprint(pmapcompcorr)\ninvisible(dev.off())\n\n#p3 &lt;- ggarrange(rmap, pmapcomp, pmapdis, pmapcompcorr, ncol = 2, nrow = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nF: The Non corrected Match is calculated omitting unpredicted cells inside the study area (orange cells).\nG: The Corrected Match is calculated considering unpredicted cells inside the study area as bad predictions.\n\n\n4.3.2 “Balanced Match” score\nThe Balanced Match consists in the arithmetic mean of the recall of each class. Recall for each class answers the question “how likely will an individual of that class be classified correctly ?”. It is “balanced” because every class has the same weight and the same importance.\n\n4.3.2.1 Non Corrected Balanced Match\nThe non corrected balanced match takes into account only L cells inside the study area.\n\nConfusion Matrix (without NL cells)\n\n\n\nCode\nbalmatch = balmatchRast(pred_sp_dis, ref_sp_mask, correct=F)\n\nbalmatch[[1]]$table\n\n\n          Reference\nPrediction  1  2  3  4  5\n         1  2  0  0  4  0\n         2  0 18  0  0  0\n         3  0  0  7  0  0\n         4  0  0  0  8  4\n         5  0  4  0  0 18\n\n\n\\(TP_{k}\\) (True Positives): observations predicted to belong to the class \\(k\\) when then really do.\n\\(FN_{k}\\) (False Negatives): observations predicted to not belong to the class \\(k\\) when they really do.\n\nRecall per class\n\n\\[\\begin{equation}\nRecall_{k} = TP_{k}/(TP_{k} + FN_{k})\n\\end{equation}\\]\n\n\nCode\nbalmatch[[1]]$byClass[, 6]\n\n\n Class: 1  Class: 2  Class: 3  Class: 4  Class: 5 \n1.0000000 0.8181818 1.0000000 0.6666667 0.8181818 \n\n\n\nNon Corrected Balanced Match (NCBM)\n\n\\[\\begin{equation}\nNCBM =  \\frac{1}{K}\\displaystyle \\sum_{k=1}^{K}Recall_{k} = 0.86\n\\end{equation}\\]\nwhere \\(K\\) (the number of classes) = 5.\n\n\n4.3.2.2 Corrected Balanced Match (Proposition 1)\nThe corrected balanced match takes into account NL cells inside the study area as bad predictions.\n\\[\\begin{equation}\nCBM_{1} = NCBM \\times (1 - \\% NL) = 0.76\n\\end{equation}\\]\n\n\n4.3.2.3 Corrected Balanced Match (Proposition 2)\n\nConfusion Matrix (including NL cells)\n\nThe 99 class in the following confusion matrix corresponds to previous NL cells in the predicted map.\n\n\nCode\nbalmatch = balmatchRast(pred_sp_dis, ref_sp_mask, correct=T)\nbalmatch[[1]]$table\n\n\n          Reference\nPrediction  1  2  3  4  5 99\n        1   2  0  0  4  0  0\n        2   0 18  0  0  0  0\n        3   0  0  7  0  0  0\n        4   0  0  0  8  4  0\n        5   0  4  0  0 18  0\n        99  3  2  1  3  1  0\n\n\n\nRecall per class\n\n\n\nCode\nbalmatch[[1]]$byClass[, 6]\n\n\n Class: 1  Class: 2  Class: 3  Class: 4  Class: 5 Class: 99 \n0.4000000 0.7500000 0.8750000 0.5333333 0.7826087        NA \n\n\n\nCorrected Balanced Match\n\nBy convention, the Recall of the impredictible class (99) is equal to 0.\n\\[\\begin{equation}\nCBM_{2} =  \\frac{1}{K}\\displaystyle \\sum_{k \\neq 99}^{K}Recall_{k}  = 0.56\n\\end{equation}\\]\nwhere \\(K\\) (the total number of classes) = 6."
  },
  {
    "objectID": "MapComp.html",
    "href": "MapComp.html",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "",
    "text": "Functions for generating, visualizing, and comparing maps (Faye et al. 2024). The example below illustrates a comparison between two maps at different spatial resolutions, with each map composed of labeled grid cells.\nTo facilitate meaningful comparison, the map with the finer resolution is disaggregated to match the coarser resolution. Corresponding grid cells are then compared based on their assigned class labels. An agreement score is computed to assess the level of correspondence between the two maps. Grid cells where labels match are marked as “Match = Yes”, providing a straightforward visual and quantitative measure of classification agreement."
  },
  {
    "objectID": "MapComp.html#required-r-packages",
    "href": "MapComp.html#required-r-packages",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "1.1 Required R Packages",
    "text": "1.1 Required R Packages\n\n\nCode\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(sp)\nlibrary(sf)\nlibrary(ggspatial)\nlibrary(ggpubr)\nlibrary(ggnewscale)\nlibrary(raster)"
  },
  {
    "objectID": "MapComp.html#required-functions",
    "href": "MapComp.html#required-functions",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "1.2 Required functions",
    "text": "1.2 Required functions\n\n\nCode\nsource('status-prop.R')\nsource('disaggregate.R')\nsource('match.R')\nsource('balanced-match.R')"
  },
  {
    "objectID": "MapComp.html#creation",
    "href": "MapComp.html#creation",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "2.1 Creation",
    "text": "2.1 Creation\nA study area map is created using specified coordinates to form a polygon with the WGS84 reference system.\n\n\nCode\ncrdref &lt;- CRS('+proj=longlat +datum=WGS84')\ncrdref2 &lt;- st_crs('+proj=longlat +datum=WGS84')\n\nlon &lt;- c(-116.8, -114.2, -112.9, -111.9, -114.2, -115.4, -117.7)\nlat &lt;- c(41.3, 42.9, 42.4, 39.8, 37.9, 38.3, 38.6)\nlonlat &lt;- cbind(lon, lat)\npolygon &lt;- Polygon(lonlat)\npols=Polygons(list(polygon), ID = \"1\")\npols = SpatialPolygons(list(pols), proj4string = CRS(\"+proj=longlat +datum=WGS84\"))\npols_sf=st_as_sf(pols)\nst_crs(pols_sf) = crdref\n\ntheme_cust = theme(panel.grid.major = element_blank(), \n         panel.grid.minor = element_blank(),\n          panel.background = element_blank(),\n         plot.background = element_rect(colour = \"black\", fill=NA, linewidth=1),\n          legend.key=element_blank(), \n          legend.text=element_text(size=15,face=\"bold\"),\n         legend.title=element_text(size=15,face=\"bold\"),\n         axis.title=element_text(size=15,face=\"bold\"),\n          axis.line = element_line(colour = \"black\"),\n          axis.text = element_text(face=\"bold\"), \n          axis.text.x = element_text(face=\"bold\", size=11),\n          axis.text.y = element_text(face=\"bold\", size=11),\n          plot.title=element_text(size=10))\n\n\nsamap = ggplot(pols_sf) +\n  labs(x=\"Longitude\", y=\"Latitude\", tag=\"A\")+\n   geom_sf(color = \"blue\", fill=\"yellow\")+\n  annotation_scale(location = \"bl\") +\n  annotation_north_arrow(location = \"tr\", which_north= \"true\", height = unit(.5, \"cm\"),\n  width = unit(.5, \"cm\"), pad_x = unit(.5, \"cm\"))+ theme_cust\n  \nsamap"
  },
  {
    "objectID": "MapComp.html#rasterization",
    "href": "MapComp.html#rasterization",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "2.2 Rasterization",
    "text": "2.2 Rasterization\nA gridded raster is generated within the study area, with red points overlaying the raster cells, and the polygon, raster, and points are visualized on a map.\n\n\nCode\nref_sp = raster(xmn = extent(pols)[1], xmx = extent(pols)[2], ymn = extent(pols)[3], ymx = extent(pols)[4], res = c(.5,.5))\n\ncrs(ref_sp) = crdref\n\npts = SpatialPoints(rasterToPoints(ref_sp))\n\npts_df=as.data.frame(pts)\nnames(pts_df) = c(\"Longitude\", \"Latitude\")\n\nvalues(ref_sp)= rep(0, ncell(ref_sp))\n\ncrs(pts) = crdref\n\n\nref_sp_df = cbind(xyFromCell(ref_sp, 1:ncell(ref_sp)), values(ref_sp))\nref_sp_df =  as.data.frame(ref_sp_df)\nnames(ref_sp_df) = c(\"Longitude\", \"Latitude\", \"Class\")\nref_sp_df$Class = as.factor(ref_sp_df$Class)\n\n\nrasmap = ggplot(pols_sf) +\n  geom_sf(color = \"blue\", fill=\"yellow\")+\n  geom_tile(data=ref_sp_df, aes(x=Longitude, y=Latitude, fill=Class), color=\"black\", alpha=0)+\n  scale_fill_manual(\"\", values = \"white\", guide=\"none\", limits=force)+\n  geom_point(data = pts_df, aes(x=Longitude, y=Latitude), color=\"red\")+\n  labs(tag=\"A'\")+\n  annotation_scale(location = \"br\", text_cex = 0.5, pad_y = unit(0.15, \"cm\")) +\n  annotation_north_arrow(location = \"tr\", which_north= \"true\", height = unit(.5, \"cm\"),\n  width = unit(.5, \"cm\"), pad_x = unit(.5, \"cm\"))+ theme_cust\nrasmap"
  },
  {
    "objectID": "MapComp.html#reference-map",
    "href": "MapComp.html#reference-map",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "3.1 Reference map",
    "text": "3.1 Reference map\nA reference map is created by assigning labels to each raster grid cell.\n\n\nCode\nr = raster(xmn = extent(pols)[1], xmx = extent(pols)[2], ymn = extent(pols)[3], ymx = extent(pols)[4], res = c(1,1))\nset.seed(12)\nvalues(r)= sample(1:5, ncell(r), replace=T)\nr2 = raster::disaggregate(r, fact=2)\n\n# Put data in the raster\nset.seed(1)\nvalues(ref_sp)= values(r2)\n\n# Mask raster\nref_sp_mask = mask(ref_sp, pols, updateNA=T)\n\nref_sp_mask_df = cbind(xyFromCell(ref_sp_mask, 1:ncell(ref_sp_mask)), values(ref_sp_mask))\nref_sp_mask_df =  as.data.frame(ref_sp_mask_df)\nnames(ref_sp_mask_df) = c(\"Longitude\", \"Latitude\", \"Class\")\n\nref_sp_mask_df$Class = as.factor(ref_sp_mask_df$Class)\n\n\npols_sf = st_as_sf(pols)\nst_crs(pols_sf) = crdref\n\ncolab = c(\"1\" = \"#dee273\",\n          \"2\" = \"#dcbf64\",\n          \"3\" = \"#a5bfdd\",\n          \"4\" = \"#1f77b6\",\n          \"5\" = \"#02426d\")\n\nrmap = ggplot(pols_sf) +\n  geom_tile(data=ref_sp_mask_df, aes(x=Longitude, y=Latitude, fill=Class), linewidth=0.1, color=\"black\")+\n  labs(title =\"Reference map\", tag=\"B\")+\n  scale_fill_manual(\"Class\", values = colab, na.value = \"white\", limits=force) +\n  geom_sf(color = \"blue\", fill=NA) +\n  annotation_scale(location = \"br\", text_cex = 0.5, pad_y = unit(0.05, \"cm\"),\n  height = unit(0.1, \"cm\")) +\n  annotation_north_arrow(location = \"tr\", which_north= \"true\", height = unit(.5, \"cm\"),\n  width = unit(.5, \"cm\"), pad_x = unit(.1, \"cm\"))+theme_cust\n\n\npng(\"refmap.png\")\nprint(rmap)\ninvisible(invisible(dev.off()))\n\nrmap"
  },
  {
    "objectID": "MapComp.html#prediction-map",
    "href": "MapComp.html#prediction-map",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "3.2 Prediction map",
    "text": "3.2 Prediction map\nA prediction map is created by assigning labels to each raster grid cell for comparison.\n\n\nCode\npred_sp = r\npred_sp[[1]][c(9,17,21)] = c(5,1,4)\n\npred_sp_mask = mask(pred_sp, pols, updateNA=T)\n\npred_sp_mask_df = cbind(xyFromCell(pred_sp_mask, 1:ncell(pred_sp_mask)), values(pred_sp_mask))\npred_sp_mask_df =  as.data.frame(pred_sp_mask_df)\nnames(pred_sp_mask_df) = c(\"Longitude\", \"Latitude\", \"Class\")\n\n\npred_sp_mask_df$Class = as.factor(pred_sp_mask_df$Class)\n\npmap = ggplot(pols_sf) +\n  geom_tile(data=pred_sp_mask_df, aes(x=Longitude, y=Latitude, fill=Class), linewidth=0.1, color=\"black\")+\n  scale_fill_manual(\"Class\", values = colab, na.value = \"white\", limits=force) +\n  labs(title =\"Prediction map\", tag=\"C\") +\n  geom_sf(color = \"blue\", fill=NA) +\n  annotation_scale(location = \"br\", text_cex = 0.5, pad_y = unit(0.05, \"cm\"),\n  height = unit(0.1, \"cm\")) +\n annotation_north_arrow(location = \"tr\", which_north= \"true\", height = unit(.5, \"cm\"),\n  width = unit(.5, \"cm\"), pad_x = unit(.1, \"cm\"))+theme_cust\n\n\npng(\"predmap.png\")\nprint(pmap)\ninvisible(dev.off())\n\npmap"
  },
  {
    "objectID": "MapComp.html#cell-size-adjustment",
    "href": "MapComp.html#cell-size-adjustment",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "4.1 Cell Size Adjustment",
    "text": "4.1 Cell Size Adjustment\nThe prediction map cells are adjusted to match the cell size of the reference map.\n\n\nCode\npred_sp_dis = disagRast(pols, pred_sp_mask, ref_sp, crdref)\n\n\npred_sp_dis_df = cbind(xyFromCell(pred_sp_dis, 1:ncell(pred_sp_dis)), values(pred_sp_dis))\npred_sp_dis_df =  as.data.frame(pred_sp_dis_df)\nnames(pred_sp_dis_df) = c(\"Longitude\", \"Latitude\", \"Class\")\n\n\npred_sp_dis_df$Class = as.factor(pred_sp_dis_df$Class)\n\npmapdis = ggplot(pols_sf) +\n  geom_tile(data=pred_sp_dis_df, aes(x=Longitude, y=Latitude, fill=Class), linewidth=0.1, color=\"black\")+\n  scale_fill_manual(\"Class\", values = colab, na.value = \"white\", limits=force) +\n  labs(title =\"Prediction map disaggregated\", tag=\"D\") +\n  geom_sf(color = \"blue\", fill=NA) +\n  annotation_scale(location = \"br\", text_cex = 0.5, pad_y = unit(0.05, \"cm\"),\n  height = unit(0.1, \"cm\")) +\n annotation_north_arrow(location = \"tr\", which_north= \"true\", height = unit(.5, \"cm\"),\n  width = unit(.5, \"cm\"), pad_x = unit(.1, \"cm\"))+theme_cust\n\n\npng(\"predismap.png\")\nprint(pmapdis)\ninvisible(dev.off())\n\npmapdis"
  },
  {
    "objectID": "MapComp.html#cell-marking",
    "href": "MapComp.html#cell-marking",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "4.2 Cell marking",
    "text": "4.2 Cell marking\nThe prediction map cells are labeled according to their location in the grid.\n\n\nCode\nref_spbis=ref_sp\nref_spbis[is.na(ref_spbis)] = 999\n# Cells outside the study area\n\noutstudy = mask(ref_spbis, pols, updateNA=T)\n\nstatus = statusProp(pred_sp_dis, ref_sp, outstudy[[1]], pols, 4326)\n\nout_df = status[[1]]\ninP_df = status[[2]]\ninNP_df = status[[3]]\nPropNL = status[[4]]\nPropL = status[[5]]\n\nallcells = rbind(out_df, inP_df, inNP_df)\nnames(allcells) = c(\"Longitude\", \"Latitude\", \"Class\", \"Location\")\n\ncolab3 = c(\"Outside\"=\"white\", \"Inside-P\"=\"green\", \"Inside-Non-P\"=\"orange\")\nlab3 = c(\"Outside\"= \"O\", \"Inside-P\"=\"L\", \"Inside-Non-P\"=\"NL\")\nstatusmap =  ggplot(pols_sf) +\n  geom_tile(data=allcells, aes(x=Longitude, y=Latitude, fill=Location), linewidth=0.1, color=\"black\")+\n  scale_fill_manual(\"Status\", values = colab3, labels = lab3, limits=force) +\n  labs(title =\"Prediction map disaggregated marking\", tag=\"E\") +\n  geom_sf(color = \"blue\", fill=NA) +\n  annotation_scale(location = \"br\", text_cex = 0.5, pad_y = unit(0.05, \"cm\"),\n  height = unit(0.1, \"cm\")) +\n  annotation_north_arrow(location = \"tr\", which_north= \"true\", height = unit(.5, \"cm\"),\n  width = unit(.5, \"cm\"), pad_x = unit(.1, \"cm\"))+theme_cust\n\n\npng(\"statusmap.png\")\nprint(statusmap)\ninvisible(dev.off())\n\nstatusmap\n\n\n\n\n\n\n\n\n\n\nThe disaggregation of the prediction map will generate borders effects.\n\n\n\nCode\np1 =  ggpubr::ggarrange(rmap, pmap, pmapdis, statusmap,  ncol = 2, nrow = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nO = Cells outside the study area. We count 45 such cells.\nL + NL = Marked cells from the original prediction map, totaling 82 cells.\nL = Marked cells within the study area. We count 72 cells, which represents 0.88% of the total cells inside the study area.\nNL = Unmarked (non-labeled) cells within the study area. We count 10 cells, corresponding to 0.12%."
  },
  {
    "objectID": "MapComp.html#compare-the-two-maps",
    "href": "MapComp.html#compare-the-two-maps",
    "title": "Comparing irregular gridded maps at different resolutions",
    "section": "4.3 Compare the two maps",
    "text": "4.3 Compare the two maps\nThe reference and the predicted maps are stacked to calculate the following “Match” and a “Balanced Match” scores.\n\n4.3.1 “Match” score\nThe match sccore corresponds to the proportion of cells that are identical in the both maps. It is calculated as follows:\n\\[\\begin{equation}\nMatch \\ (Yes) = \\frac{N_{+}}{N_{+} + N_{-}}\n\\end{equation}\\]\nwhere \\(N_{+}\\) are cells which labels are similar in the two maps and \\(N_{-}\\) are cells which labels are different in the two maps.\n\n\nCode\nmatchstats = matchRast(pred_sp_dis, ref_sp_mask, precision=2, correct=F)\n\nmatch = subset(matchstats[[1]][,], layer==1)[,3]\n\nmismatch = subset(matchstats[[1]][,], layer==0)[,3]\n\ncomp_sp = cbind(xyFromCell(matchstats[[2]], 1:ncell(matchstats[[2]])), values(matchstats[[2]]))\ncomp_sp_df =  as.data.frame(comp_sp)\nnames(comp_sp_df) = c(\"Longitude\", \"Latitude\", \"Class\")\n\n\ncomp_sp_df$Class = as.factor(comp_sp_df$Class)\n\ncolab2 = c(\"1\" = \"seagreen\", \"0\" = \"yellow\")\n\npmapcomp = ggplot(pols_sf) +\n  geom_tile(data=comp_sp_df, aes(x=Longitude, y=Latitude, fill=Class), linewidth=0.1, color=\"black\")+\n  scale_fill_manual(\"Match\", values = colab2, labels= c(\"1\"=str_glue(\"Yes = {match}\"), \"0\"= str_glue(\"No = {mismatch}\")), na.value = NA, limits=force) +\n  new_scale_fill()+\n  geom_tile(data=subset(allcells, Location==\"Inside-Non-P\"), aes(x=Longitude, y=Latitude), fill=\"orange\", linewidth=0.1, color=\"black\")+\n  labs(title =\"Non corrected Match\", tag=\"F\") +\n  geom_sf(color = \"blue\", fill=NA) +\n  annotation_scale(location = \"br\", text_cex = 0.5, pad_y = unit(0.05, \"cm\"),\n  height = unit(0.1, \"cm\")) +\n  annotation_north_arrow(location = \"tr\", which_north= \"true\", height = unit(.5, \"cm\"),\n  width = unit(.5, \"cm\"), pad_x = unit(.1, \"cm\"))+theme_cust\n\npng(\"pmapcomp.png\")\nprint(pmapcomp)\ninvisible(dev.off())\n\n\n########################################################################\n\nmatchstats = matchRast(pred_sp_dis, ref_sp_mask, precision=2, correct=T)\n\nmatch = subset(matchstats[[1]][,], layer==1)[,3]\n\nmismatch = subset(matchstats[[1]][,], layer==0)[,3]\n\n\ncomp_sp_corr = cbind(xyFromCell(matchstats[[2]], 1:ncell(matchstats[[2]])), values(matchstats[[2]]))\ncomp_sp_corr_df =  as.data.frame(comp_sp_corr)\nnames(comp_sp_corr_df) = c(\"Longitude\", \"Latitude\", \"Class\")\n\ncomp_sp_corr_df$Class = as.factor(comp_sp_corr_df$Class)\n\ncolab2 = c(\"1\" = \"seagreen\", \"0\" = \"yellow\")\n\npmapcompcorr = ggplot(pols_sf) +\n  geom_tile(data=comp_sp_corr_df, aes(x=Longitude, y=Latitude, fill=Class), linewidth=0.1, color=\"black\")+\n   scale_fill_manual(\"Match\", values = colab2, labels= c(\"1\"=str_glue(\"Yes = {match}\"), \"0\"= str_glue(\"No = {mismatch}\")), na.value = NA, limits=force) +\n  labs(title =\"Corrected Match \", tag=\"G\") +\n  geom_sf(color = \"blue\", fill=NA) +\n  annotation_scale(location = \"br\", text_cex = 0.5, pad_y = unit(0.05, \"cm\"),\n  height = unit(0.1, \"cm\")) +\n  annotation_north_arrow(location = \"tr\", which_north= \"true\", height = unit(.5, \"cm\"),\n  width = unit(.5, \"cm\"), pad_x = unit(.1, \"cm\"))+theme_cust\n\npng(\"pmapcompcorr.png\")\nprint(pmapcompcorr)\ninvisible(dev.off())\n\n#p3 &lt;- ggarrange(rmap, pmapcomp, pmapdis, pmapcompcorr, ncol = 2, nrow = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nF: The Non corrected Match is calculated omitting unpredicted cells inside the study area (orange cells).\nG: The Corrected Match is calculated considering unpredicted cells inside the study area as bad predictions.\n\n\n4.3.2 “Balanced Match” score\nThe Balanced Match consists in the arithmetic mean of the recall of each class. Recall for each class answers the question “how likely will an individual of that class be classified correctly ?”. It is “balanced” because every class has the same weight and the same importance.\n\n4.3.2.1 Non Corrected Balanced Match\nThe non corrected balanced match takes into account only L cells inside the study area.\n\nConfusion Matrix (without NL cells)\n\n\n\nCode\nbalmatch = balmatchRast(pred_sp_dis, ref_sp_mask, correct=F)\n\nbalmatch[[1]]$table\n\n\n          Reference\nPrediction  1  2  3  4  5\n         1  2  0  0  4  0\n         2  0 18  0  0  0\n         3  0  0  7  0  0\n         4  0  0  0  8  4\n         5  0  4  0  0 18\n\n\n\\(TP_{k}\\) (True Positives): observations predicted to belong to the class \\(k\\) when then really do.\n\\(FN_{k}\\) (False Negatives): observations predicted to not belong to the class \\(k\\) when they really do.\n\nRecall per class\n\n\\[\\begin{equation}\nRecall_{k} = TP_{k}/(TP_{k} + FN_{k})\n\\end{equation}\\]\n\n\nCode\nbalmatch[[1]]$byClass[, 6]\n\n\n Class: 1  Class: 2  Class: 3  Class: 4  Class: 5 \n1.0000000 0.8181818 1.0000000 0.6666667 0.8181818 \n\n\n\nNon Corrected Balanced Match (NCBM)\n\n\\[\\begin{equation}\nNCBM =  \\frac{1}{K}\\displaystyle \\sum_{k=1}^{K}Recall_{k} = 0.86\n\\end{equation}\\]\nwhere \\(K\\) (the number of classes) = 5.\n\n\n4.3.2.2 Corrected Balanced Match (Proposition 1)\nThe corrected balanced match takes into account NL cells inside the study area as bad predictions.\n\\[\\begin{equation}\nCBM_{1} = NCBM \\times (1 - \\% NL) = 0.76\n\\end{equation}\\]\n\n\n4.3.2.3 Corrected Balanced Match (Proposition 2)\n\nConfusion Matrix (including NL cells)\n\nThe 99 class in the following confusion matrix corresponds to previous NL cells in the predicted map.\n\n\nCode\nbalmatch = balmatchRast(pred_sp_dis, ref_sp_mask, correct=T)\nbalmatch[[1]]$table\n\n\n          Reference\nPrediction  1  2  3  4  5 99\n        1   2  0  0  4  0  0\n        2   0 18  0  0  0  0\n        3   0  0  7  0  0  0\n        4   0  0  0  8  4  0\n        5   0  4  0  0 18  0\n        99  3  2  1  3  1  0\n\n\n\nRecall per class\n\n\n\nCode\nbalmatch[[1]]$byClass[, 6]\n\n\n Class: 1  Class: 2  Class: 3  Class: 4  Class: 5 Class: 99 \n0.4000000 0.7500000 0.8750000 0.5333333 0.7826087        NA \n\n\n\nCorrected Balanced Match\n\nBy convention, the Recall of the impredictible class (99) is equal to 0.\n\\[\\begin{equation}\nCBM_{2} =  \\frac{1}{K}\\displaystyle \\sum_{k \\neq 99}^{K}Recall_{k}  = 0.56\n\\end{equation}\\]\nwhere \\(K\\) (the total number of classes) = 6."
  }
]